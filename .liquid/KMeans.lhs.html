<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>KMeans.lhs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types
K-Means Clustering
==================


<div class="hidden">
\begin{code}
<pre><span class=hs-linenum> 7: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--short-names"</span>    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 8: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-termination"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 9: </span>
<span class=hs-linenum>10: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>KMeans</span> <span class='hs-layout'>(</span><span class='hs-varid'>kmeans</span><span class='hs-layout'>,</span> <span class='hs-varid'>kmeans1</span><span class='hs-layout'>,</span> <span class='hs-varid'>nearest</span><span class='hs-layout'>,</span> <span class='hs-varid'>mergeCluster</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>11: </span>
<span class=hs-linenum>12: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span> <span class='hs-layout'>(</span><span class='hs-varid'>minimumBy</span><span class='hs-layout'>)</span>
<span class=hs-linenum>13: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>MapReduce</span>
<span class=hs-linenum>14: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Assert</span>
<span class=hs-linenum>15: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>List</span>
<span class=hs-linenum>16: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span><span class='hs-layout'>,</span> <span class='hs-varid'>repeat</span><span class='hs-layout'>,</span> <span class='hs-varid'>foldr</span><span class='hs-layout'>,</span> <span class='hs-varid'>zipWith</span><span class='hs-layout'>)</span>
<span class=hs-linenum>17: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>M</span>
<span class=hs-linenum>18: </span>
<span class=hs-linenum>19: </span><span class='hs-definition'>centroid</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Point</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Point</span>
<span class=hs-linenum>20: </span><span class='hs-definition'>distance</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Point</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Point</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Double</span>
<span class=hs-linenum>21: </span><span class='hs-definition'>nearest</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Centering</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Point</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Center</span>
<span class=hs-linenum>22: </span><span class='hs-definition'>mergeCluster</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cluster</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cluster</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cluster</span>
<span class=hs-linenum>23: </span><span class='hs-definition'>kmeans1</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-conid'>Point</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Centering</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Centering</span>
<span class=hs-linenum>24: </span><span class='hs-definition'>kmeans</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-conid'>Point</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Centering</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Centering</span>
</pre>\end{code}
</div>

Next, lets use our `MapReduce` library to implement
[K-Means Clustering](http://en.wikipedia.org/wiki/K-means_clustering)


Points and Clusters
-------------------

First, lets define the various types that model the key entities in clustering.


\begin{code}
<pre><span class=hs-linenum>39: </span><span class='hs-comment'>-- | N-Dimensional Point</span>
<span class=hs-linenum>40: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Point</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List</span> <span class='hs-conid'>Double</span>
<span class=hs-linenum>41: </span>
<span class=hs-linenum>42: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>PointN</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ListN</span> <span class='hs-conid'>Double</span> <span class='hs-conid'>N</span> <span class='hs-keyword'>@-}</span>
</pre>\end{code}

**A Center** is a number between `0` and `k` (written `CenterK k`).

\begin{code}
<pre><span class=hs-linenum>48: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Center</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>49: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>CenterK</span> <span class='hs-conid'>K</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>0</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;</span> <span class='hs-conid'>K</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>\end{code}

**A Centering** is a map from `Center`s to `Point`s. Our clustering algorithm
will aim to group a (large) set of `Point`s into `k` representatives. Thus, a
*k-n-Centering* is a map from `CenterK k` to `PointN n`:

\begin{code}
<pre><span class=hs-linenum>57: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Centering</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span> <span class='hs-conid'>Center</span> <span class='hs-conid'>Point</span>
<span class=hs-linenum>58: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>CenteringKN</span> <span class='hs-conid'>K</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span> <span class='hs-layout'>(</span><span class='hs-conid'>CenterK</span> <span class='hs-conid'>K</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>PointN</span> <span class='hs-conid'>N</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
</pre>\end{code}

**A Cluster** is a pair of a *number* of points (denoting the cluster size)
and the *co-ordinates* denoting the (sum of) the co-ordinates of all the points
in the cluster. We represent `n`-dimensional clusters as `ClusterN n`;  note that
the cluster size is *strictly positive* as we will never represent empty clusters.

\begin{code}
<pre><span class=hs-linenum>67: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Cluster</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Point</span><span class='hs-layout'>)</span>
<span class=hs-linenum>68: </span>
<span class=hs-linenum>69: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>ClusterN</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pos</span><span class='hs-layout'>,</span> <span class='hs-conid'>PointN</span> <span class='hs-conid'>N</span><span class='hs-layout'>)</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>70: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Pos</span>        <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>\end{code}

(a) Computing Euclidean Distance
--------------------------------

If you did the `zipWith` problem, then you should see an error in
the implementation of `distance` which computes the
[Euclidean Distance](http://en.wikipedia.org/wiki/Euclidean_distance)
between two points. Fix the **specification** (not the code) of `distance` so
that the code is verified by LH:

\begin{code}
<pre><span class=hs-linenum>83: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>distance</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PointN</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PointN</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Double</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>84: </span><a class=annot href="#"><span class=annottext>x1:{v : Int | v &gt;= 0} -&gt; {v : (List Double) | size v == x1} -&gt; {v : (List Double) | size v == x1} -&gt; Double</span><span class='hs-definition'>distance</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &gt;= 0}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>{v : (List Double) | size v == n}</span><span class='hs-varid'>px</span></a> <a class=annot href="#"><span class=annottext>{v : (List Double) | size v == n}</span><span class='hs-varid'>py</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Double -&gt; Double</span><span class='hs-varid'>sqrt</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>Double -&gt; (List Double) -&gt; Double</span><span class='hs-varid'>foldr</span></a> <a class=annot href="#"><span class=annottext>x1:Double -&gt; x2:Double -&gt; {v : Double | v == x1 + x2}</span><span class='hs-layout'>(</span></a><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : Double | v == 0.0}</span><span class='hs-num'>0</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>Double -&gt; Double -&gt; Double</span><span class='hs-varid'>zipWith</span></a> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>Double</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>Double</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>Double</span><span class='hs-varid'>x</span></a><a class=annot href="#"><span class=annottext>Double -&gt; Integer -&gt; Double</span><span class='hs-varop'>^</span></a><span class='hs-num'>2</span> <a class=annot href="#"><span class=annottext>x1:Double -&gt; x2:Double -&gt; {v : Double | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <a class=annot href="#"><span class=annottext>Double</span><span class='hs-varid'>y</span></a><a class=annot href="#"><span class=annottext>Double -&gt; Integer -&gt; Double</span><span class='hs-varop'>^</span></a><span class='hs-num'>2</span><span class='hs-layout'>)</span> <span class='hs-varid'>px</span> <span class='hs-varid'>py</span>
</pre>\end{code}

(b) Map Points To Nearest Center
--------------------------------

Use `distance` to fill in the **implementation** of `nearest`
so that LH verifies the given type signature.

\begin{code}
<pre><span class=hs-linenum>94: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>nearest</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CenteringKN</span> <span class='hs-varid'>k</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PointN</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CenterK</span> <span class='hs-varid'>k</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>95: </span><a class=annot href="#"><span class=annottext>x1:{v : Int | v &gt;= 0} -&gt; x2:{v : Int | v &gt;= 0} -&gt; (Map {v : Int | 0 &lt;= v
                                                                  &amp;&amp; v &lt; x1} {v : (List Double) | size v == x2}) -&gt; {v : (List Double) | size v == x2} -&gt; {v : Int | 0 &lt;= v
                                                                                                                                                                     &amp;&amp; v &lt; x1}</span><span class='hs-definition'>nearest</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &gt;= 0}</span><span class='hs-varid'>k</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &gt;= 0}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>(Map {v : Int | 0 &lt;= v
                &amp;&amp; v &lt; k} {v : (List Double) | size v == n})</span><span class='hs-varid'>centers</span></a> <a class=annot href="#"><span class=annottext>{v : (List Double) | size v == n}</span><span class='hs-varid'>p</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Map {v : Int | v /= k
                &amp;&amp; v &lt;= k
                &amp;&amp; v &lt; k
                &amp;&amp; 0 &lt;= v
                &amp;&amp; v &gt;= 0} Double) -&gt; {v : Int | v /= k
                                                 &amp;&amp; v &lt;= k
                                                 &amp;&amp; v &lt; k
                                                 &amp;&amp; 0 &lt;= v
                                                 &amp;&amp; v &gt;= 0}</span><span class='hs-varid'>minKeyMap</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{VV : (List Double) | size VV == n} -&gt; Double</span><span class='hs-conid'>M</span></a><span class='hs-varop'>.</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>{VV : (List Double) | size VV == n}</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : Int | v &gt;= 0} -&gt; {v : (List Double) | size v == x1} -&gt; {v : (List Double) | size v == x1} -&gt; Double | v == KMeans.distance}</span><span class='hs-varid'>distance</span></a> <span class='hs-varid'>n</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>centers</span>
</pre>\end{code}

You may want to use the helper `minKeyMap` that computes the key
with the smallest value in a `Map`:

\begin{code}
<pre><span class=hs-linenum>102: </span><span class='hs-comment'>--- &gt;&gt;&gt; minKeyMap (M.fromList [(0, 12), (1, 23), (2, 7), (3,18)])</span>
<span class=hs-linenum>103: </span><span class='hs-comment'>--- 2</span>
<span class=hs-linenum>104: </span><span class='hs-definition'>minKeyMap</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span> <span class='hs-varid'>k</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>k</span>
<span class=hs-linenum>105: </span><a class=annot href="#"><span class=annottext>(Ord b) =&gt; (Map a b) -&gt; a</span><span class='hs-definition'>minKeyMap</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [(a, b)] | len v &gt;= 0} -&gt; a</span><span class='hs-varid'>minKeyList</span></a> <span class='hs-varop'>.</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>toList</span>
<span class=hs-linenum>106: </span>
<span class=hs-linenum>107: </span><span class='hs-definition'>minKeyList</span>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>k</span><span class='hs-layout'>,</span><span class='hs-varid'>v</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>k</span>
<span class=hs-linenum>108: </span><a class=annot href="#"><span class=annottext>(Ord b) =&gt; {VV : [(a, b)] | len VV &gt;= 0} -&gt; a</span><span class='hs-definition'>minKeyList</span></a> <a class=annot href="#"><span class=annottext>{VV : [(a, b)] | len VV &gt;= 0}</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(a, b) -&gt; a</span><span class='hs-varid'>fst</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>((a, b) -&gt; (a, b) -&gt; Ordering) -&gt; [(a, b)] -&gt; (a, b)</span><span class='hs-varid'>minimumBy</span></a> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>(a, b)</span><span class='hs-varid'>x1</span></a> <a class=annot href="#"><span class=annottext>(a, b)</span><span class='hs-varid'>x2</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : Ordering | (v == GHC.Types.EQ &lt;=&gt; x1 == x2)
                                &amp;&amp; (v == GHC.Types.LT &lt;=&gt; x1 &lt; x2)
                                &amp;&amp; (v == GHC.Types.GT &lt;=&gt; x1 &gt; x2)}</span><span class='hs-varid'>compare</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>snd</span></a> <span class='hs-varid'>x1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>snd</span></a> <span class='hs-varid'>x2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
</pre>\end{code}

When you are done, you should get the following behavior:


\begin{code}
<pre><span class=hs-linenum>115: </span><span class='hs-comment'>-- &gt;&gt;&gt; test_nearest</span>
<span class=hs-linenum>116: </span><span class='hs-comment'>-- 1</span>
<span class=hs-linenum>117: </span><a class=annot href="#"><span class=annottext>{VV : Int | 0 &lt;= VV
            &amp;&amp; VV &gt;= 0}</span><span class='hs-definition'>test_nearest</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : Int | v &gt;= 0} -&gt; x2:{v : Int | v &gt;= 0} -&gt; (Map {v : Int | 0 &lt;= v
                                                                       &amp;&amp; v &lt; x1} {v : (List Double) | size v == x2}) -&gt; {v : (List Double) | size v == x2} -&gt; {v : Int | 0 &lt;= v
                                                                                                                                                                          &amp;&amp; v &lt; x1} | v == KMeans.nearest}</span><span class='hs-varid'>nearest</span></a> <span class='hs-num'>3</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>[({v : Int | 0 &lt;= v
             &amp;&amp; v &gt;= 0}, (List Double))] -&gt; (Map {v : Int | 0 &lt;= v
                                                            &amp;&amp; v &gt;= 0} (List Double))</span><span class='hs-conid'>M</span></a><span class='hs-varop'>.</span><span class='hs-varid'>fromList</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-varid'>p0</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-varid'>p1</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-num'>2</span><span class='hs-layout'>,</span> <span class='hs-varid'>p2</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>p</span>
<span class=hs-linenum>118: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>119: </span>    <span class='hs-varid'>p</span><span class='hs-layout'>,</span> <span class='hs-varid'>p0</span><span class='hs-layout'>,</span> <span class='hs-varid'>p1</span><span class='hs-layout'>,</span> <span class='hs-varid'>p2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Point</span>
<span class=hs-linenum>120: </span>    <a class=annot href="#"><span class=annottext>(List Double)</span><span class='hs-varid'>p0</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(List Double) -&gt; {v : (List Double) | size v == 1 + size x1}</span><span class='hs-varid'>add</span></a> <a class=annot href="#"><span class=annottext>{v : Double | v == 0.0}</span><span class='hs-num'>0.0</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(List Double) -&gt; {v : (List Double) | size v == 1 + size x1}</span><span class='hs-varid'>add</span></a> <a class=annot href="#"><span class=annottext>{v : Double | v == 0.0}</span><span class='hs-num'>0.0</span></a> <span class='hs-varid'>empty</span><span class='hs-layout'>)</span>
<span class=hs-linenum>121: </span>    <a class=annot href="#"><span class=annottext>(List Double)</span><span class='hs-varid'>p1</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(List Double) -&gt; {v : (List Double) | size v == 1 + size x1}</span><span class='hs-varid'>add</span></a> <a class=annot href="#"><span class=annottext>{v : Double | v == 3.0}</span><span class='hs-num'>3.0</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(List Double) -&gt; {v : (List Double) | size v == 1 + size x1}</span><span class='hs-varid'>add</span></a> <a class=annot href="#"><span class=annottext>{v : Double | v == 0.0}</span><span class='hs-num'>0.0</span></a> <span class='hs-varid'>empty</span><span class='hs-layout'>)</span>
<span class=hs-linenum>122: </span>    <a class=annot href="#"><span class=annottext>(List Double)</span><span class='hs-varid'>p2</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(List Double) -&gt; {v : (List Double) | size v == 1 + size x1}</span><span class='hs-varid'>add</span></a> <a class=annot href="#"><span class=annottext>{v : Double | v == 0.0}</span><span class='hs-num'>0.0</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(List Double) -&gt; {v : (List Double) | size v == 1 + size x1}</span><span class='hs-varid'>add</span></a> <a class=annot href="#"><span class=annottext>{v : Double | v == 3.0}</span><span class='hs-num'>3.0</span></a> <span class='hs-varid'>empty</span><span class='hs-layout'>)</span>
<span class=hs-linenum>123: </span>    <a class=annot href="#"><span class=annottext>(List Double)</span><span class='hs-varid'>p</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(List Double) -&gt; {v : (List Double) | size v == 1 + size x1}</span><span class='hs-varid'>add</span></a> <a class=annot href="#"><span class=annottext>{v : Double | v == 2.9}</span><span class='hs-num'>2.9</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(List Double) -&gt; {v : (List Double) | size v == 1 + size x1}</span><span class='hs-varid'>add</span></a> <a class=annot href="#"><span class=annottext>{v : Double | v == 1.1}</span><span class='hs-num'>1.1</span></a> <span class='hs-varid'>empty</span><span class='hs-layout'>)</span>
</pre>\end{code}

(c) Reduce Clusters
-------------------

Fix the **specification** below so that that LH verifies `mergeCluster`
which takes two `Cluster` and merges them by adding up their points
and centers. (Leave the code unmodified).

\begin{code}
<pre><span class=hs-linenum>134: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>mergeCluster</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClusterN</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClusterN</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClusterN</span> <span class='hs-varid'>n</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>135: </span><a class=annot href="#"><span class=annottext>x1:{v : Int | v &gt;= 0} -&gt; ({v : Int | v &gt; 0}, {v : (List Double) | size v == x1}) -&gt; ({v : Int | v &gt; 0}, {v : (List Double) | size v == x1}) -&gt; ({v : Int | v &gt; 0}, {v : (List Double) | size v == x1})</span><span class='hs-definition'>mergeCluster</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &gt;= 0}</span><span class='hs-varid'>n</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>n1</span><span class='hs-layout'>,</span> <span class='hs-varid'>p1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>n2</span><span class='hs-layout'>,</span> <span class='hs-varid'>p2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : Int | v == n1 + n2}</span><span class='hs-varid'>n1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-varid'>n2</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>x1:(List Double) -&gt; {v : (List Double) | size v == size x1} -&gt; {v : (List Double) | size v == size x1}</span><span class='hs-varid'>zipWith</span></a> <a class=annot href="#"><span class=annottext>x1:Double -&gt; x2:Double -&gt; {v : Double | v == x1 + x2}</span><span class='hs-layout'>(</span></a><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <span class='hs-varid'>p1</span> <span class='hs-varid'>p2</span><span class='hs-layout'>)</span>
</pre>\end{code}

**Note:** The code above uses `zipWith`; so you will only see the error
and be able to fix it, *after* you solve that problem.

(d) Convert Cluster into Centroid Point
---------------------------------------

The `centroid` function converts a `Cluster` into a single `Point` by
dividing each co-ordinate with the cluster size. Fix the **specification**
of `centroid` so that LH verifies the call to `divide`:

\begin{code}
<pre><span class=hs-linenum>149: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>centroid</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PointN</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{i :</span> <span class='hs-conid'>Nat</span> <span class='hs-keyword'>| i &gt; 0 }</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PointN</span> <span class='hs-varid'>n</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>150: </span><a class=annot href="#"><span class=annottext>x1:{v : Int | v &gt;= 0} -&gt; {v : (List Double) | size v == x1} -&gt; {v : Int | v &gt;= 0
                                                                          &amp;&amp; v &gt; 0} -&gt; {v : (List Double) | size v == x1}</span><span class='hs-definition'>centroid</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &gt;= 0}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>{v : (List Double) | size v == n}</span><span class='hs-varid'>p</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &gt;= 0
           &amp;&amp; v &gt; 0}</span><span class='hs-varid'>sz</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Double -&gt; Double</span><span class='hs-varid'>map</span></a> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><a class=annot href="#"><span class=annottext>Double</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>Double</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{v : Double -&gt; {v : Int | v /= 0} -&gt; Double | v == Assert.divide}</span><span class='hs-varop'>`divide`</span></a> <span class='hs-varid'>sz</span><span class='hs-layout'>)</span> <span class='hs-varid'>p</span>
</pre>\end{code}

**Note:** The code below uses `map` from `List.lhs`; and hence
your solution will only work if you solved that problem first.


(e) Iterative Clustering
--------------------

The Kmeans clustering algorithm is shown below:



\begin{code}
<pre><span class=hs-linenum>165: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>kmeans</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>166: </span>              <span class='hs-conid'>List</span> <span class='hs-layout'>(</span><span class='hs-conid'>PointN</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CenteringKN</span> <span class='hs-varid'>k</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CenteringKN</span> <span class='hs-varid'>k</span> <span class='hs-varid'>n</span>
<span class=hs-linenum>167: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>168: </span><a class=annot href="#"><span class=annottext>{v : Int | v &gt;= 0} -&gt; x2:{v : Int | v &gt;= 0} -&gt; x3:{v : Int | v &gt;= 0} -&gt; (List {v : (List Double) | size v == x3}) -&gt; (Map {v : Int | 0 &lt;= v
                                                                                                                                     &amp;&amp; v &lt; x2} {v : (List Double) | size v == x3}) -&gt; (Map {v : Int | 0 &lt;= v
                                                                                                                                                                                                       &amp;&amp; v &lt; x2} {v : (List Double) | size v == x3})</span><span class='hs-definition'>kmeans</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &gt;= 0}</span><span class='hs-varid'>steps</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &gt;= 0}</span><span class='hs-varid'>k</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &gt;= 0}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>(List {v : (List Double) | size v == n})</span><span class='hs-varid'>ps</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : Int | 0 &lt;= VV
            &amp;&amp; VV &gt;= 0} -&gt; (a -&gt; a) -&gt; a -&gt; a</span><span class='hs-varid'>repeat</span></a> <span class='hs-varid'>steps</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:{v : Int | v &gt;= 0} -&gt; x2:{v : Int | v &gt;= 0} -&gt; (List {v : (List Double) | size v == x2}) -&gt; (Map {v : Int | 0 &lt;= v
                                                                                                                    &amp;&amp; v &lt; x1} {v : (List Double) | size v == x2}) -&gt; (Map {v : Int | 0 &lt;= v
                                                                                                                                                                                      &amp;&amp; v &lt; x1} {v : (List Double) | size v == x2}) | v == KMeans.kmeans1}</span><span class='hs-varid'>kmeans1</span></a> <span class='hs-varid'>k</span> <span class='hs-varid'>n</span> <span class='hs-varid'>ps</span><span class='hs-layout'>)</span>
<span class=hs-linenum>169: </span>
<span class=hs-linenum>170: </span><span class='hs-definition'>repeat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>171: </span><a class=annot href="#"><span class=annottext>{VV : Int | 0 &lt;= VV
            &amp;&amp; VV &gt;= 0} -&gt; (a -&gt; a) -&gt; a -&gt; a</span><span class='hs-definition'>repeat</span></a> <span class='hs-num'>0</span> <a class=annot href="#"><span class=annottext>a -&gt; a</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
<span class=hs-linenum>172: </span><span class='hs-definition'>repeat</span> <span class='hs-varid'>n</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : Int | 0 &lt;= VV
            &amp;&amp; VV &gt;= 0} -&gt; (a -&gt; a) -&gt; a -&gt; a</span><span class='hs-varid'>repeat</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>n</span></a><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : a -&gt; a | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : a -&gt; a | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
</pre>\end{code}

In essence we start with an initial `k` centering, and repeatedly update it by calling
`kmeans1` which takes as input a list of `n` dimensional points, a centering and returns
a new centering (with `k` centers and `n` dimensional points). The new centers are computed by:

1. Mapping each point to its `nearest` center,
2. Grouping all the points mapped to a center into a new cluster,
3. Reducing the clusters by adding up all the points inside them, and
4. Normalizing each cluster to its `centroid`.

\begin{code}
<pre><span class=hs-linenum>185: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>kmeans1</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>186: </span>               <span class='hs-conid'>List</span> <span class='hs-layout'>(</span><span class='hs-conid'>PointN</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CenteringKN</span> <span class='hs-varid'>k</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CenteringKN</span> <span class='hs-varid'>k</span> <span class='hs-varid'>n</span>
<span class=hs-linenum>187: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>188: </span><a class=annot href="#"><span class=annottext>x1:{v : Int | v &gt;= 0} -&gt; x2:{v : Int | v &gt;= 0} -&gt; (List {v : (List Double) | size v == x2}) -&gt; (Map {v : Int | 0 &lt;= v
                                                                                                               &amp;&amp; v &lt; x1} {v : (List Double) | size v == x2}) -&gt; (Map {v : Int | 0 &lt;= v
                                                                                                                                                                                 &amp;&amp; v &lt; x1} {v : (List Double) | size v == x2})</span><span class='hs-definition'>kmeans1</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &gt;= 0}</span><span class='hs-varid'>k</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &gt;= 0}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>(List {v : (List Double) | size v == n})</span><span class='hs-varid'>ps</span></a> <a class=annot href="#"><span class=annottext>(Map {v : Int | 0 &lt;= v
                &amp;&amp; v &lt; k} {v : (List Double) | size v == n})</span><span class='hs-varid'>cs</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (Map {v : Int | v /= k
                     &amp;&amp; v &lt;= k
                     &amp;&amp; v &lt; k
                     &amp;&amp; 0 &lt;= v
                     &amp;&amp; v &gt;= 0} ({v : Int | v &gt;= 0
                                            &amp;&amp; 0 &lt;= v
                                            &amp;&amp; v &gt; 0
                                            &amp;&amp; v /= 0}, {v : (List Double) | size v == n})) | v == newClusters}</span><span class='hs-varid'>normalize</span></a> <span class='hs-varid'>newClusters</span>
<span class=hs-linenum>189: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>190: </span>    <span class='hs-varid'>normalize</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span> <span class='hs-varid'>a</span> <span class='hs-conid'>Cluster</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span> <span class='hs-varid'>a</span> <span class='hs-conid'>Point</span>
<span class=hs-linenum>191: </span>    <a class=annot href="#"><span class=annottext>(Map a ({VV : Int | VV /= 0
                    &amp;&amp; VV &gt; 0
                    &amp;&amp; 0 &lt;= VV
                    &amp;&amp; VV &gt;= 0}, {VV : (List Double) | size VV == n})) -&gt; (Map a {VV : (List Double) | size VV == n})</span><span class='hs-varid'>normalize</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>({VV : Int | VV /= 0
             &amp;&amp; VV &gt; 0
             &amp;&amp; 0 &lt;= VV
             &amp;&amp; VV &gt;= 0}, {VV : (List Double) | size VV == n}) -&gt; {VV : (List Double) | size VV == n}</span><span class='hs-conid'>M</span></a><span class='hs-varop'>.</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>({v : Int | v /= 0
            &amp;&amp; v &gt; 0
            &amp;&amp; 0 &lt;= v
            &amp;&amp; v &gt;= 0}, {v : (List Double) | size v == n})</span><span class='hs-keyglyph'>\</span></a><span class='hs-layout'>(</span><span class='hs-varid'>sz</span><span class='hs-layout'>,</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : Int | v &gt;= 0} -&gt; {v : (List Double) | size v == x1} -&gt; {v : Int | v &gt;= 0
                                                                               &amp;&amp; v &gt; 0} -&gt; {v : (List Double) | size v == x1} | v == KMeans.centroid}</span><span class='hs-varid'>centroid</span></a> <span class='hs-varid'>n</span> <span class='hs-varid'>p</span> <span class='hs-varid'>sz</span><span class='hs-layout'>)</span>
<span class=hs-linenum>192: </span>    <a class=annot href="#"><span class=annottext>(Map {v : Int | v /= k
                &amp;&amp; v &lt;= k
                &amp;&amp; v &lt; k
                &amp;&amp; 0 &lt;= v
                &amp;&amp; v &gt;= 0} ({v : Int | v &gt;= 0
                                       &amp;&amp; 0 &lt;= v
                                       &amp;&amp; v &gt; 0
                                       &amp;&amp; v /= 0}, {v : (List Double) | size v == n}))</span><span class='hs-varid'>newClusters</span></a>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>({v : (List Double) | size v == n} -&gt; (List ({v : Int | v /= k
                                                        &amp;&amp; v &lt;= k
                                                        &amp;&amp; v &lt; k
                                                        &amp;&amp; 0 &lt;= v
                                                        &amp;&amp; v &gt;= 0}, ({v : Int | v &gt;= 0
                                                                                &amp;&amp; 0 &lt;= v
                                                                                &amp;&amp; v &gt; 0
                                                                                &amp;&amp; v /= 0}, {v : (List Double) | size v == n})))) -&gt; (({v : Int | v &gt;= 0
                                                                                                                                                  &amp;&amp; 0 &lt;= v
                                                                                                                                                  &amp;&amp; v &gt; 0
                                                                                                                                                  &amp;&amp; v /= 0}, {v : (List Double) | size v == n}) -&gt; ({v : Int | v &gt;= 0
                                                                                                                                                                                                                &amp;&amp; 0 &lt;= v
                                                                                                                                                                                                                &amp;&amp; v &gt; 0
                                                                                                                                                                                                                &amp;&amp; v /= 0}, {v : (List Double) | size v == n}) -&gt; ({v : Int | v &gt;= 0
                                                                                                                                                                                                                                                                              &amp;&amp; 0 &lt;= v
                                                                                                                                                                                                                                                                              &amp;&amp; v &gt; 0
                                                                                                                                                                                                                                                                              &amp;&amp; v /= 0}, {v : (List Double) | size v == n})) -&gt; (List {v : (List Double) | size v == n}) -&gt; (Map {v : Int | v /= k
                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; v &lt;= k
                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; v &lt; k
                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; 0 &lt;= v
                                                                                                                                                                                                                                                                                                                                                                                             &amp;&amp; v &gt;= 0} ({v : Int | v &gt;= 0
                                                                                                                                                                                                                                                                                                                                                                                                                    &amp;&amp; 0 &lt;= v
                                                                                                                                                                                                                                                                                                                                                                                                                    &amp;&amp; v &gt; 0
                                                                                                                                                                                                                                                                                                                                                                                                                    &amp;&amp; v /= 0}, {v : (List Double) | size v == n}))</span><span class='hs-varid'>mapReduce</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : (List Double) | size v == n} -&gt; (List ({v : Int | v /= k
                                                               &amp;&amp; v &lt;= k
                                                               &amp;&amp; v &lt; k
                                                               &amp;&amp; 0 &lt;= v
                                                               &amp;&amp; v &gt;= 0
                                                               &amp;&amp; v == fst v}, {v : ({v : Int | v == 1
                                                                                                &amp;&amp; v &lt;= k
                                                                                                &amp;&amp; v /= 0
                                                                                                &amp;&amp; v &gt; 0
                                                                                                &amp;&amp; 0 &lt;= v
                                                                                                &amp;&amp; v &gt;= 0
                                                                                                &amp;&amp; v == fst v}, {v : (List Double) | v == x1
                                                                                                                                     &amp;&amp; v &gt;= x1
                                                                                                                                     &amp;&amp; v &lt;= x1
                                                                                                                                     &amp;&amp; size v == n
                                                                                                                                     &amp;&amp; v == snd v}) | v == snd v})) | v == fm}</span><span class='hs-varid'>fm</span></a> <a class=annot href="#"><span class=annottext>{v : ({v : Int | v /= 0
                 &amp;&amp; v &gt; 0
                 &amp;&amp; 0 &lt;= v
                 &amp;&amp; v &gt;= 0}, {v : (List Double) | size v == n}) -&gt; ({v : Int | v /= 0
                                                                               &amp;&amp; v &gt; 0
                                                                               &amp;&amp; 0 &lt;= v
                                                                               &amp;&amp; v &gt;= 0}, {v : (List Double) | size v == n}) -&gt; ({v : Int | v &gt; 0}, {v : (List Double) | size v == n}) | v == fr}</span><span class='hs-varid'>fr</span></a> <span class='hs-varid'>ps</span>
<span class=hs-linenum>193: </span>    <a class=annot href="#"><span class=annottext>p:{VV : (List Double) | size VV == n} -&gt; (List ({VV : Int | VV /= k
                                                            &amp;&amp; VV &lt;= k
                                                            &amp;&amp; VV &lt; k
                                                            &amp;&amp; 0 &lt;= VV
                                                            &amp;&amp; VV &gt;= 0
                                                            &amp;&amp; VV == fst VV}, {VV : ({VV : Int | VV == 1
                                                                                                 &amp;&amp; VV &lt;= k
                                                                                                 &amp;&amp; VV /= 0
                                                                                                 &amp;&amp; VV &gt; 0
                                                                                                 &amp;&amp; 0 &lt;= VV
                                                                                                 &amp;&amp; VV &gt;= 0
                                                                                                 &amp;&amp; VV == fst VV}, {VV : (List Double) | VV == p
                                                                                                                                         &amp;&amp; VV &gt;= p
                                                                                                                                         &amp;&amp; VV &lt;= p
                                                                                                                                         &amp;&amp; size VV == n
                                                                                                                                         &amp;&amp; VV == snd VV}) | VV == snd VV}))</span><span class='hs-varid'>fm</span></a> <a class=annot href="#"><span class=annottext>{VV : (List Double) | size VV == n}</span><span class='hs-varid'>p</span></a>          <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>({v : Int | v /= k
            &amp;&amp; v &lt;= k
            &amp;&amp; v &lt; k
            &amp;&amp; 0 &lt;= v
            &amp;&amp; v &gt;= 0}, ({v : Int | v == 1
                                    &amp;&amp; v &lt;= k
                                    &amp;&amp; v /= 0
                                    &amp;&amp; v &gt; 0
                                    &amp;&amp; 0 &lt;= v
                                    &amp;&amp; v &gt;= 0
                                    &amp;&amp; v == fst v}, {v : (List Double) | v == p
                                                                         &amp;&amp; v &gt;= p
                                                                         &amp;&amp; v &lt;= p
                                                                         &amp;&amp; size v == n
                                                                         &amp;&amp; v == snd v}))</span><span class='hs-varid'>singleton</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:{v : Int | v &gt;= 0} -&gt; x2:{v : Int | v &gt;= 0} -&gt; (Map {v : Int | 0 &lt;= v
                                                                       &amp;&amp; v &lt; x1} {v : (List Double) | size v == x2}) -&gt; {v : (List Double) | size v == x2} -&gt; {v : Int | 0 &lt;= v
                                                                                                                                                                          &amp;&amp; v &lt; x1} | v == KMeans.nearest}</span><span class='hs-varid'>nearest</span></a> <span class='hs-varid'>k</span> <span class='hs-varid'>n</span> <span class='hs-varid'>cs</span> <span class='hs-varid'>p</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-num'>1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>194: </span>    <a class=annot href="#"><span class=annottext>({VV : Int | VV /= 0
             &amp;&amp; VV &gt; 0
             &amp;&amp; 0 &lt;= VV
             &amp;&amp; VV &gt;= 0}, {VV : (List Double) | size VV == n}) -&gt; ({VV : Int | VV /= 0
                                                                               &amp;&amp; VV &gt; 0
                                                                               &amp;&amp; 0 &lt;= VV
                                                                               &amp;&amp; VV &gt;= 0}, {VV : (List Double) | size VV == n}) -&gt; ({v : Int | v &gt; 0}, {v : (List Double) | size v == n})</span><span class='hs-varid'>fr</span></a> <a class=annot href="#"><span class=annottext>({VV : Int | VV /= 0
             &amp;&amp; VV &gt; 0
             &amp;&amp; 0 &lt;= VV
             &amp;&amp; VV &gt;= 0}, {VV : (List Double) | size VV == n})</span><span class='hs-varid'>wp1</span></a> <a class=annot href="#"><span class=annottext>({VV : Int | VV /= 0
             &amp;&amp; VV &gt; 0
             &amp;&amp; 0 &lt;= VV
             &amp;&amp; VV &gt;= 0}, {VV : (List Double) | size VV == n})</span><span class='hs-varid'>wp2</span></a>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : Int | v &gt;= 0} -&gt; ({v : Int | v &gt; 0}, {v : (List Double) | size v == x1}) -&gt; ({v : Int | v &gt; 0}, {v : (List Double) | size v == x1}) -&gt; ({v : Int | v &gt; 0}, {v : (List Double) | size v == x1}) | v == KMeans.mergeCluster}</span><span class='hs-varid'>mergeCluster</span></a> <span class='hs-varid'>n</span> <span class='hs-varid'>wp1</span> <span class='hs-varid'>wp2</span>
</pre>\end{code}

Fix the code and specifications above so that LH verifies the the specification for `kmeans` and `kmeans1`
(i.e. verifies this entire module.)

**Hint:** If you did the above problems correctly, you should have to do nothing here.
Otherwise, think about what type `normalize` should have and try to work backwards
to verify that type.

</body>
</html>